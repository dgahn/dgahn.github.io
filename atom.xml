<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-08T15:04:36.266Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>안덕기</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java - 추상 클래스와 인터페이스</title>
    <link href="http://yoursite.com/2019/08/08/04-java-abstraction/"/>
    <id>http://yoursite.com/2019/08/08/04-java-abstraction/</id>
    <published>2019-08-08T13:38:22.595Z</published>
    <updated>2019-08-08T15:04:36.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>신입 면접 질문 목록을 보면 추상 클래스와 인터페이스에 대해서 묻는 경우가 많다. 나는 추상 클래스는 거의 사용해본적이 없고 인터페이스를 만들고 나서 해당 인터페이스의 명세를 구현하는 경우만 많았다. 왜 그것들을 사용하지는에 대해서 이번 기회에 정리하면 좋겠다고 생각이 들어서 정리를 해본다.</p><br><h2 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h2><p>추상클래스와 인터페이스를 이야기하기 전에 추상화에 대해서 이야기하는 것이 좋을 듯하다. <a href="https://dgahn.github.io/2019/08/07/03-java-oop/" rel="external nofollow noopener noreferrer" target="_blank">Java-객체 지향 프로그래밍</a>에서 이야기 했지만 객체 지향 프로그래밍은 자료구조와 데이터에 대해서 먼저 설계를 하고 흐름에 따라서 코드를 작성한다. 이 때, 자료구조와 함수에 대해서 설계를 할 때 <strong>특정 사물에 대해서 공통적인 속성 또는 기능을 정의하는 행위</strong>를 <strong>추상화</strong>라고 한다. </p><p>추상화를 통해서 우리는 객체를 정의할 수 있는데 추상화 과정에서 <strong>비슷 기능이지만 결과나 구현 내용이 다른 경우</strong>가 있다. 이런 경우, 공통적인 속성 또는 기능등을 추상클래스 또는 인터페이스로 선언을 하고 사용할 수 있다.</p><br><h2 id="추상-클래스"><a href="#추상-클래스" class="headerlink" title="추상 클래스"></a>추상 클래스</h2><p>추상 클래스는 실제 <strong>클래스</strong>이다. 다만, 이 추상 클래스를 상속 받는 하위 클래스가 추상 클래스에서 선언한 추상 메소드들을 보고 반드시 <strong>Overridng</strong> 해야하는 메소드가 무엇인지 알 수 있다. 그렇기 때문에 우리는 추상클래스를 사용하면 일반 클래스처럼 사용하고 하위 클래스가 구현해야되는 기능들을 명시할 수 있다. 그리고 일반 클래스처럼 변수를 선언할 수 있기 때문에 하위 클래스가 해당 변수를 선언하지 않아도 추상 클래스를 통해서 하위 클래스에서 사용할 수 있다.</p><br><h2 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h2><p>인터페이스는 인터페이스를 구현할 구현체가 구현할 기능등을 명세해놓는다. 하지만 변수가 아닌 상수들만 선언할 수 있다. 자바 8 이전 버전에서는 인터페이스에서는 추상 메소드만 선언할 수 있었지만 자바 8 이후부터는 디폴트 메소드, 정적 메소드를 모두 선언해서 사용할 수 있다. 그렇기 때문에 추상 클래스처럼 유사하게 사용할 수 있게 되었다.</p><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>추상 클래스와 인터페이스는 어떤 사물을 추상화하여 여러가지 방법으로 사용하는 것(다형성)을 고려할 때 쓰인다. 그렇기 때문에 너무나 비슷한 것 같은데 무슨 차이가 있을까? 마지막으로 아래에서 공통점과 차이점에 대해서 나열하는 것으로 마무리 하도록 하겠다.</p><h3 id="공통점"><a href="#공통점" class="headerlink" title="공통점"></a>공통점</h3><ul><li><p>추상 메소드, 디폴트 메소드, 정적 메소드를 선언할 수 있다.</p></li><li><p>해당 클래스를 직접 사용하기보단 별도의 클래스를 상속 또는 구현해서 사용한다.</p></li></ul><h3 id="차이점"><a href="#차이점" class="headerlink" title="차이점"></a>차이점</h3><ul><li><p>인터페이스는 객체화할 수 없다. (추상 클래스는 객체화가 가능하다.)</p></li><li><p>인터페이스는 변수를 가질 수 없고 상수만 가질 수 있다. (추상 클래스는 변수를 가질 수 있다.)</p></li><li><p>추상 클래스는 다중 상속이 불가능하다. (인터페이스는 해당 구현체가 여러개의 인터페이스를 구현할 수 있다.)</p></li></ul><p>그렇기 때문에 내가 내린 결론은 아래와 같다.</p><h3 id="사용-용도"><a href="#사용-용도" class="headerlink" title="사용 용도"></a>사용 용도</h3><p>추상 클래스 : 공통적으로 사용할 변수가 있고 추상화 한번에 모든 것이 추상화가 해결된다면 추상 클래스를 사용하는 것이 적합하다.</p><p>인터페이스 : 공통적으로 사용할 상수만 있고 추상화 단계가 복잡하여 구현체가 여러가지를 구현해야하는 경우 사용하는 것이 적합해보인다.</p><p>자바의 대표적인 프레임워크인 스프링 코드를 어설프게 봤을 때는 구현해야하는 클래스에 추상화한 클래스나 인터페이스가 가진 변수를 사용해야하는 경우에는 추상 클래스를 사용하고 어떤 기능에 대해서 명세만 하는 경우에는 인터페이스를 사용하는 것 같다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;신입 면접 질문 목록을 보면 추상 클래스와 인터페이스에 대해서 묻는 경우가 많다. 나는 추상 클래스는 거의 사용해본적이 없고 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 객체 지향 프로그래밍</title>
    <link href="http://yoursite.com/2019/08/07/03-java-oop/"/>
    <id>http://yoursite.com/2019/08/07/03-java-oop/</id>
    <published>2019-08-07T02:20:41.762Z</published>
    <updated>2019-08-07T14:17:59.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>나는 프로그래밍을 대학교에서 C언어로 처음 접했다. 그리고 다음으로 객체 지향 언어라고 불리는 자바를 접하게 되었는데 객체 지향이라는 말이 무엇인지 자바 수업이 끝날 때까지 이해하지 못하였다. 그리고 훗날 세미나를 하면서 객체 지향이라는 것에 대해서 관심을 갖게 된 이유는 내가 만든 프로그램을 수정하면서 너무 많은 것을 변경해야되면서 관심을 갖게 되었다. 객체 지향적으로 설계하는 것이 얼마나 중요한지를 코드를 작성하면서 깨달았다… 아직은 객체지향적인 설계를 하진 못하지만 ^^.. 객체지향의 특징에 대해서 다시한번 정리하려고 한다. </p><br><h2 id="절차-지향-VS-객체-지향"><a href="#절차-지향-VS-객체-지향" class="headerlink" title="절차 지향 VS 객체 지향"></a>절차 지향 VS 객체 지향</h2><p>먼저, 주의해야할 점이 있다. 절차 지향과 객체 지향은 상반된 개념이 아니다. 즉, 절차 지향의 반대가 객체 지향이 아니고 객체 지향의 반대가 절차 지향은 아니다. 그저 바라보는 관점이 다른 것이다. <strong>절차 지향의 경우 순서와 흐름을 먼저 설계하고 자료구조와 함수들을 설계</strong>하는 방식이고 <strong>객체 지향의 경우 자료구조와 함수들을 먼저 설계하고 순서와 흐름을 설계</strong>하는 방식이다. 그렇기 때문에 완전히 다른 방식이 아니라 중점을 어디에 두었냐를 생각해야한다.</p><br><h2 id="객체-지향-프로그래밍의-특징"><a href="#객체-지향-프로그래밍의-특징" class="headerlink" title="객체 지향 프로그래밍의 특징"></a>객체 지향 프로그래밍의 특징</h2><p>객체 지향 프로그램의 가장 큰 장점은 <strong>유지 보수가 용이</strong> 하다는 것이다. 그 이유는 해당 프로그램이 객체 지향적으로 설계된 프로그램이라면 자료구조와 메소드들을 분리할 수 있는 형태로 먼저 설계를 했기 때문에 다른 것으로 대체할 수 있기 때문이다. </p><p>하지만 그에 비해 좋은 설계를 하기 위해서는 많은 시간이 필요하고 객체를 별도로 생성하기 때문에 메모리도 많이 사용하며 여러가지 객체들이 복합적으로 처리하는 것들이 많기 때문에 절차지향에 비해 실제 컴퓨터가 처리하는 시간도 많이 걸린다.</p><br><h3 id="객체-지향의-장점"><a href="#객체-지향의-장점" class="headerlink" title="객체 지향의 장점"></a>객체 지향의 장점</h3><ul><li>유지 보수가 용이하다.</li></ul><h3 id="객체-지향의-단점"><a href="#객체-지향의-단점" class="headerlink" title="객체 지향의 단점"></a>객체 지향의 단점</h3><ul><li><p>좋은 설계를 하기 위한 시간과 노력이 많이 필요하다.</p></li><li><p>메모리를 많이 차지한다.</p></li><li><p>컴퓨터의 실제 처리시간이 비교적 오래 걸린다.     </p></li></ul><br><h2 id="객체-지향의-3가지-요소"><a href="#객체-지향의-3가지-요소" class="headerlink" title="객체 지향의 3가지 요소"></a>객체 지향의 3가지 요소</h2><p>객체 지향 프로그램을 하는데 있어서 중요시 여기는 3가지 요소가 있다. <strong>캡슐화, 상속, 다형성</strong>인데 각각의 특징이 어떤 것을 의미하는지 정리해보자.</p><br><h3 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h3><p>캡슐화는 <strong>객체의 내부 구현 내용을 숨기는 것</strong>이다. 숨기는 이유는 간단하다. 객체를 <strong>손상</strong>되지 않도록 하는 것이다. 자바에서는 객체의 필드와 메소드를 묶어서 사용을 많이 하는데 자바에서 말하는 POJO(Plain Old Java Object)가 바로 그 예시이다. POJO의 예시는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POJO처럼 필드와 메소드를 묶어서 <strong>a</strong> 클래스가 가진 필드 <strong>b</strong> 숨기면 항상 <strong>setB</strong>로 <strong>b</strong>의 값을 변경해야한다. 이렇게 필드를 숨기는 것도 캡슐화의 일종이다. 아래 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  .. 생략</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.initB()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> initB &#123;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .. 생략</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 <strong>b</strong>가 음수라면 <strong>b</strong>를 음수로 초기화해야하는 로직이 있어야한다고 가정하자. 그리고 그 로직을 별도의 메소드로 작성했다고 하고 외부에서는 그 메소드를 호출할 필요가 없다고 하면 위와 같이 접근 제한자로 객체의 기능을 숨길 수가 있다. 그러면 외부에서는 함부로 필드 <strong>b</strong>를 초기화할 수가 없을 것이다.</p><p>이렇게 객체을 손상시키지 않기 위해서 외부에 필드나 메소드를 은닉하는 행위를 <strong>캡슐화</strong>라고 부른다.</p><br><h3 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h3><p>상속은 이미 구현되어 있는 기능(필드 또는 메소드)을 다른 객체가 그대로 사용하거나 변형해서 사용할 수 있도록 해주는 기능이다. 그렇기 때문에 상위 객체(상속을 해주는 객체)의 기능을 이어 받은 하위 객체(상속을 받는 객체)를 작성하는 것이 아예 새로 작성하는 것보다 더 적인 노력이 든다.</p><h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><p>하위 객체가 생성할 때는 상위 객체가 미리 생성이 되어야 한다. 자바에서는 <strong>primitive</strong> 타입을 제외한 타입을 <strong>Heap</strong> 영역에 생성되는데 하위 객체의 생성자를 호출하면 상위 객체의 생성자도 호출되기 때문에 상위 객체가 <strong>Heap</strong>영역에 같이 생성이 된다. (단, 이는 기본 생성자에서 자동으로 상위 객체의 기본 생성자를 불러와주는 것이다. 만약 별도로 만든 생성자라면 해당 생성자 첫 줄에 <strong>super()</strong> 를 통해서 상위 객체의 생성자를 호출해야한다.)</p><br><h3 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h3><p>다형성은 선언한 메소드나 클래스를 다양한 방법으로 동작시키는 것을 의미한다. 아래를 보자. </p><h4 id="1-상속을-이용한-다형성-활용"><a href="#1-상속을-이용한-다형성-활용" class="headerlink" title="1.상속을 이용한 다형성 활용"></a>1.상속을 이용한 다형성 활용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="comment">//  private A a = new A();</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 상속이나 인터페이스를 이용하여 하나의 클래스에 서로 다른 객체를 할당해서 사용할 수 있다. 그러면 <strong>A</strong> 객체를 할당 했을 때는 <strong>a.get1()</strong> 을 호출해서 사용할 수 있고, <strong>B</strong> 객체를 할당 했을 때는 <strong>a.get1()</strong> 또는 <strong>a.get2()</strong> 을 호출하여 사용할 수 있다. 그러므로 A 클래스를 여러가지 방법으로 동작시킬 수 있다.</p><h4 id="2-Override을-이용한-다형성-활용"><a href="#2-Override을-이용한-다형성-활용" class="headerlink" title="2.@Override을 이용한 다형성 활용"></a>2.@Override을 이용한 다형성 활용</h4><p>@Override를 활용하면 <strong>메소드를 재정의</strong>할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="comment">//  private A a = new A();</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러므로 <strong>A</strong> 객체를 할당하느냐 <strong>B</strong> 객체를 할당하느냐에 따라 <strong>a.get()</strong> 를 다르게 사용할 수 있다.</p><h4 id="3-Overloading을-이용한-다형성-활용"><a href="#3-Overloading을-이용한-다형성-활용" class="headerlink" title="3.Overloading을 이용한 다형성 활용"></a>3.Overloading을 이용한 다형성 활용</h4><p>오버로딩을 활용하면 <strong>메소드의 이름을 중복</strong>해서 사용할수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> String x, <span class="keyword">final</span> String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조건은 아래와 같다.</p><ul><li><p>메소드의 이름은 같아야 한다.</p></li><li><p>반환형은 달라도 된다.</p></li><li><p>파라미터의 갯수나 자료형이 달라야한다.</p></li></ul><p>참고 자료</p><ul><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">이것이 자바다.</a> </li><li><a href="https://m.blog.naver.com/atalanta16/220249264429" rel="external nofollow noopener noreferrer" target="_blank">스파게티 코드님 블로그</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;나는 프로그래밍을 대학교에서 C언어로 처음 접했다. 그리고 다음으로 객체 지향 언어라고 불리는 자바를 접하게 되었는데 객체 지
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 변수(Primitive)와 메모리 사용</title>
    <link href="http://yoursite.com/2019/07/31/02-java-variable/"/>
    <id>http://yoursite.com/2019/07/31/02-java-variable/</id>
    <published>2019-07-31T14:06:27.843Z</published>
    <updated>2019-07-31T14:06:27.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>회사에서 lombok을 쓰다보니 원시 타입을 잘 사용하지 않아 생각이 나질 않는다. 한번 정리할 겸 해서 블로그에 올려본다.</p><br><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><p>Java의 Primitive(원시)타입은 총 8가지가 있다.</p><table><thead><tr><th align="center">기본 타입</th><th align="center">메모리 사용 크기</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1 byte / 8 bit</td></tr><tr><td align="center">char</td><td align="center">2 byte / 16 bit</td></tr><tr><td align="center">short</td><td align="center">2 byte / 16 bit</td></tr><tr><td align="center">int</td><td align="center">4 byte / 32 bit</td></tr><tr><td align="center">long</td><td align="center">8 byte / 64 bit</td></tr><tr><td align="center">float</td><td align="center">4 byte / 32 bit</td></tr><tr><td align="center">double</td><td align="center">8 byte / 64 bit</td></tr><tr><td align="center">boolean</td><td align="center">1 byte / 8 bit</td></tr></tbody></table><br><h2 id="메모리-사용"><a href="#메모리-사용" class="headerlink" title="메모리 사용"></a>메모리 사용</h2><p>모든 프로그램은 아래와 같은 방식으로 메모리를 분리해서 사용한다.</p><p><img src="https://i.imgur.com/tHgmkma.png" alt="2"></p><p><strong>Java</strong>는 데이터 저장 영역을 아래와 같이 더 분류한다.</p><p><img src="https://i.imgur.com/bpzBCzb.png" alt="1"></p><p>Primitive 타입의 변수들은 스택 영역에 값이 직접 할당된다. 그래서 변수를 어떤 타입으로 선언했냐에 따라 이 스택 영역에 해당 변수가 얼마나 많은 크기를 사용하냐가 결정된다.</p><p>참고 자료</p><ul><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">스프링 입문을 위한 자바 객체 지향의 원리와 이해</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;회사에서 lombok을 쓰다보니 원시 타입을 잘 사용하지 않아 생각이 나질 않는다. 한번 정리할 겸 해서 블로그에 올려본다.&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 자바 개발 환경</title>
    <link href="http://yoursite.com/2019/07/31/01-java-jdk/"/>
    <id>http://yoursite.com/2019/07/31/01-java-jdk/</id>
    <published>2019-07-31T14:06:22.272Z</published>
    <updated>2019-07-31T14:06:22.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>자바의 가장 큰 장점 중의 하나는 “Write once, run anywhere.(한 번 작성하면 어디서든 실행된다.)” 이다. 이 것을 가능하게 해주는 것은 자바가 가지는 특별한 개발 환경 덕분이다. 자바의 세계는 아래와 같은 3가지 도구로 구성되어 있다.</p><ul><li><p>JVM(Java Virtual Machine) : 자바 가상 기계</p></li><li><p>JRE(Java Runtime Environment) : 자바 실행 환경</p></li><li><p>JDK(Java Development Kit) : 자바 개발 도구</p></li></ul><h2 id="JVM-JRE-JDK-관계"><a href="#JVM-JRE-JDK-관계" class="headerlink" title="JVM, JRE, JDK 관계"></a>JVM, JRE, JDK 관계</h2><ul><li><p>JRE = JVM + 표준 클래스 라이브러리</p></li><li><p>JDK = JRE + 개발에 필요한 도구</p></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM은 컴퓨터로 따지면 물리적인 기계에 해당한다. 자바가 실행할 수 있도록 가상의 공간을 내 컴퓨터에 할당한다. Java 소스 코드를 javac 컴파일러를 통해서 컴파일을 하면 바이트 코드로 변환이 되는데 이 때, 이 바이트 코드를 JVM이 JIT 컴파일 방식으로 코드를 실행한다. (JIT: 실행하는 부분만 필요한 시점에 컴파일 하는 방식)</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>Java Runtime Environment. 말 그대로 자바를 실행할 수 있는 환경을 제공해준다. 예를 들어, 바이트 코드로 전환된 코드를 JVM에게 전달(적재)하는 역할을 JRE에 있는 Java class loader가 해준다.</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JRE, Java 바이트 코드 컴파일러, Java 디버거등으로 구성되어 있다. 실제로 Java를 통해서 개발을 할 때 필요한 도구등을 제공해준다. 간단하게 생각하면 System.out.println()이 JDK에서 제공하는 표준 라이브러리 중 하나인 java.lang에 속한 메소드 중 하나이다.</p><p>참고 자료</p><ul><li><a href="https://namu.wiki/w/Java%20Virtual%20Machine" rel="external nofollow noopener noreferrer" target="_blank">https://namu.wiki/w/Java%20Virtual%20Machine</a></li><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">이것이 자바다.</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;자바의 가장 큰 장점 중의 하나는 “Write once, run anywhere.(한 번 작성하면 어디서든 실행된다.)” 이다
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo로 블로그 만들기</title>
    <link href="http://yoursite.com/2019/07/30/00-hexo-blog/"/>
    <id>http://yoursite.com/2019/07/30/00-hexo-blog/</id>
    <published>2019-07-30T08:57:27.436Z</published>
    <updated>2019-08-04T10:37:17.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>블로그를 만들고 싶다는 생각에 인터넷을 찾아서 보았다.<br><del>gitlab에서 한번 만든적이 있는데 거의 사용하지 않고 있다.</del> 만들면서 참고한 사이트가 있다.<br>블로그에서는 친절하게 설명을 해주고 있는데 나는 정말 간단하게 명령어를 순서대로 나열할 예정이다. 그러니 자세한 설명을 듣고 싶은 사람은 <a href="https://juicyjusung.github.io/2019/01/23/hexo/Hexo-github-pages%EB%A1%9C-%EA%B7%B8%EB%9F%B4%EC%8B%B8%ED%95%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/" rel="external nofollow noopener noreferrer" target="_blank">링크</a>를 참고하길 바란다.<br>정말 설명을 잘해주셔서 블로그를 띄우는데 많은 도움이 되었다. 다시한번 말하지만 상세한 설정법을 알고 싶으면 링크를 찾아가서 하는 것을 추천한다.</p><h2 id="Git-amp-npm-install"><a href="#Git-amp-npm-install" class="headerlink" title="Git &amp; npm install"></a>Git &amp; npm install</h2><ul><li><a href="https://nodejs.org/ko/download/" rel="external nofollow noopener noreferrer" target="_blank">Node.js 설치</a></li><li><a href="https://git-scm.com/downloads" rel="external nofollow noopener noreferrer" target="_blank">Git 설치</a></li></ul><h2 id="hexo-설치"><a href="#hexo-설치" class="headerlink" title="hexo 설치"></a>hexo 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g hexo</span><br><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><h2 id="hexo-blog-init"><a href="#hexo-blog-init" class="headerlink" title="hexo blog init"></a>hexo blog init</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo-blog(프로젝트 명)</span><br></pre></td></tr></table></figure><h2 id="hexo-실행"><a href="#hexo-실행" class="headerlink" title="hexo 실행"></a>hexo 실행</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo serve</span><br></pre></td></tr></table></figure><h2 id="새로운-테마-적용"><a href="#새로운-테마-적용" class="headerlink" title="새로운 테마 적용"></a>새로운 테마 적용</h2><p>새로운 테마를 적용하기전에 모듈을 몇개 다운 받는다. 무슨 모듈인지는 모르겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-generator-json-content --save &amp;&amp; npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>새로운 테마를 찾아서 클론 해온다. 여기선 <a href="http://firework.studio/archer-demo/" rel="external nofollow noopener noreferrer" target="_blank">archer</a>를 사용한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/fi3ework/hexo-theme-archer.git</span><br></pre></td></tr></table></figure><p>마지막으로 프로젝트 루트의 <strong>__config.yml</strong>에서 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">archer</span></span><br></pre></td></tr></table></figure><p>라고 적용하면 새로운 테마 적용은 완성~ 완성된 테마를 구경해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>배포하는 법에 대해서는 <a href="https://juicyjusung.github.io/2019/01/24/hexo/Hexo-github-pages%EB%A1%9C-%EA%B7%B8%EB%9F%B4%EC%8B%B8%ED%95%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/" rel="external nofollow noopener noreferrer" target="_blank">링크</a>을 참고하면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;블로그를 만들고 싶다는 생각에 인터넷을 찾아서 보았다.&lt;br&gt;&lt;del&gt;gitlab에서 한번 만든적이 있는데 거의 사용하지 않고
      
    
    </summary>
    
    
  </entry>
  
</feed>
