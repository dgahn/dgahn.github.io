<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-19T02:18:55.812Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>안덕기</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OOP - SOLID - 3.LSP(리스코프 치환 원칙)</title>
    <link href="http://yoursite.com/2019/08/19/07-oop-solid-3/"/>
    <id>http://yoursite.com/2019/08/19/07-oop-solid-3/</id>
    <published>2019-08-19T00:56:35.259Z</published>
    <updated>2019-08-19T02:18:55.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>이전에 포스팅 하였던 2가지 원칙은 예전에 어설프게 공부했던 기억이 있다. 그런데 <strong>LSP</strong>은 전혀 기억이 없는 원칙이다. 이해하기가 좀 어려운데 하나하나 차근차근 포스팅 해보도록 하려고 한다.</p><br><h2 id="리스코프-치환-원칙이란"><a href="#리스코프-치환-원칙이란" class="headerlink" title="리스코프 치환 원칙이란?"></a>리스코프 치환 원칙이란?</h2><p>리스코프 치환 원칙을 한줄로 표현하면 <strong>서브 클래스는 is a kind of 슈퍼클래스</strong>이다. 말그대로 <strong>서브 클래스는 슈퍼 클래스의 한 종류이다.</strong>라는 의미다. 그래서 그게 무슨 의미인데? 라는 의문이 생길 것이다. </p><p>우리가 프로그래밍을 하다보면 상속 받은 <strong>서브 클래스</strong>를 슈퍼 클래스 대신 주입시킬 경우가 있다. 그러면 기존에 사용하던 <strong>슈퍼 클래스의 역할</strong>을 <strong>서브 클래스</strong>가 그대로 수행할 수 있어야 한다. 여기서 중요한 점은 <strong>슈퍼 클래스</strong>를 사용하던 별도의 클래스가 <strong>서브 클래스</strong>로 바꿔서 사용하였을 때, 그 결과가 달라지면 안된다는 것이다. </p><p>그렇다면 <strong>슈퍼 클래스</strong>가 하던 기능들(메소드)이 변경되지 않아야 한다. 그래서 리스코프 치환원칙을 지키는 가장 쉬운 방법은 <strong>서브 클래스</strong>에서 <strong>슈퍼 클래스</strong>의 메소드를 <strong>Overriding</strong> 하지 않는 것이다.</p><br><h2 id="리스코프-치환-원칙을-이해하기-위한-예제"><a href="#리스코프-치환-원칙을-이해하기-위한-예제" class="headerlink" title="리스코프 치환 원칙을 이해하기 위한 예제"></a>리스코프 치환 원칙을 이해하기 위한 예제</h2><p>예제는 책에 나온 예제를 활용한다. </p><ul><li>슈퍼 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>리스코프 치환 원칙을 지키는 서브 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountedBag</span> <span class="keyword">extends</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> discountedRate = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiscounted</span><span class="params">(<span class="keyword">double</span> discountedRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountedRate = discountedRate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyDiscount</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setPrice(price - (<span class="keyword">int</span>)(discountedRate * price));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>리스코프 치환 원칙을 지키지 않는 서브 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountedBag</span> <span class="keyword">extends</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> discountedRate = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiscounted</span><span class="params">(<span class="keyword">double</span> discountedRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discountedRate = discountedRate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setPrice(price - (<span class="keyword">int</span>)(discountedRate * price));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리스코프 치환 원칙을 지키기 위해서는 아래의 마지막 <strong>getPrice()</strong> 메소드가 동일한 값을 가져야 한다.</p><table><thead><tr><th align="left">Bag</th><th align="left">DiscountedBag</th></tr></thead><tbody><tr><td align="left">Bag bag = new Bag();<br>bag.setPrice(50000);<br>System.out.println(bag.getPrice());</td><td align="left">Bag bag = new DiscountedBag();<br>bag.setPrice(50000);<br>System.out.println(bag.getPrice());</td></tr></tbody></table><ul><li><p>슈퍼클래스 결과 : 50000</p></li><li><p>리스코프 치환 원칙을 지킨 서브 클래스 결과 : 50000</p></li><li><p>리스코프 치환 원칙을 지키지 못한 클래스 결과  : 40000</p></li></ul><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>리스코프 치환 원칙은 상속, 다형성에 관련된 주제인거 같다. 중요한 것은 상속으로 만들어진 객체에 의해 다른 객체에 영향을 끼치지 않는 것이 아닐까한다. 영향을 주면 그 쪽 코드를 다시 수정해야하니까. 확실히 상속은 잘 알고 써야 좋은 것이지 쓸데 없이 남용하면 독이 되는 것 같다.</p><br><p>참고 자료</p><ul><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B3400922670" rel="external nofollow noopener noreferrer" target="_blank">Java 객체지향 디자인 패턴</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;이전에 포스팅 하였던 2가지 원칙은 예전에 어설프게 공부했던 기억이 있다. 그런데 &lt;strong&gt;LSP&lt;/strong&gt;은 전혀
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OOP - SOLID - 2.OCP(개방 폐쇄 원칙)</title>
    <link href="http://yoursite.com/2019/08/13/06-oop-solid-2/"/>
    <id>http://yoursite.com/2019/08/13/06-oop-solid-2/</id>
    <published>2019-08-13T14:18:51.564Z</published>
    <updated>2019-08-19T02:18:55.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>어제에 이어서 <strong>SOLID</strong> 중에 두번째인 <strong>개방 - 폐쇄 원칙</strong>에 대해서 정리를 해보려고 한다. </p><br><h2 id="개방-폐쇄-원칙이란"><a href="#개방-폐쇄-원칙이란" class="headerlink" title="개방 폐쇄 원칙이란?"></a>개방 폐쇄 원칙이란?</h2><p>개방 폐쇄원칙은 <strong>확장과 변경에는 개방되어 있지만 코드의 수정에는 폐쇄적이어야 한다</strong>는 의미이다. 다시 말하면 <strong>코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다</strong>라는 의미다. </p><p>솔직히 처음 글을 읽었을 때, 이게 말이 되는 일인가? 라는 생각이 들었다. 기능을 변경하려면 코드를 변경해야하는 것이 아닌가? 라는 생각이 들었다. 기능을 변경하는 것에 대해서 다르게 생각해보자. 아래의 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    b.b()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 객체가 있다고 하자. 나는 <strong>b.b()</strong>의 기능을 다양한 형태로 사용하고 싶다. 그러면 <strong>B</strong> 클래스 코드에 가서 <strong>b()</strong>메소드를 변경해야할까? 메소드나 객체를 다양한 방법으로 사용할 수 있도록 하는 객체지향의 특징인 다형성을 생각해보자. [<a href="https://dgahn.github.io/2019/08/07/03-java-oop/" rel="external nofollow noopener noreferrer" target="_blank">이전 포스트</a>]</p><p>상속이나 인터페이스를 사용하여 다양한 기능을 가진 클래스를 만들어서 사용하고 싶은 기능을 가진 객체를 주입시키면 된다. 즉, 추상화 작업을 통해서 인터페이스나 추상 클래스를 선언하고 여러가지 구현체를 만든 다음, <strong>객체 A를 생성하는 부분에서 자신이 원하는 구현체를 주입</strong>시키면 된다. 그러면 <strong>A</strong>클래스나 <strong>B</strong>클래스를 수정하지 않았지만 기능을 확장하거나 변경할 수 있게 된다.</p><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>다시 말하지만 <strong>SOLID</strong>는 객체 지향 설에서 <strong>프로그램의 유지보수와 확장</strong>을 용이하게 하기 위한 원칙들이다. 그러므로 객체의 기능이 변경됬을 때, 연관된 객체들의 코드의 변경을 최소화해야한다. 이런면에서 <strong>개방 폐쇄 원칙</strong>은 비슷한 기능을 하는 객체(인터페이스의 구현체)를 추가하여 기능을 확장하고 기존의 객체 코드를 변경하지 않는 것을 의미하는 것 같다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;어제에 이어서 &lt;strong&gt;SOLID&lt;/strong&gt; 중에 두번째인 &lt;strong&gt;개방 - 폐쇄 원칙&lt;/strong&gt;에 대해
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OOP - SOLID - 1.SRP(단일 책임 원칙)</title>
    <link href="http://yoursite.com/2019/08/12/05-oop-solid-1/"/>
    <id>http://yoursite.com/2019/08/12/05-oop-solid-1/</id>
    <published>2019-08-12T11:31:12.226Z</published>
    <updated>2019-08-19T02:18:55.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p><strong>SOLID</strong> 우리가 객체 지향 패턴에 대해서 공부하게 되면 처음으로 듣게 되는 단어이다. <strong>SOLID</strong>는 꼭 Java에서만 쓰이는 용어는 아니다. 객체 지향 프로그램을 설계하는데 <strong>프로그램의 유지 보수와 확장</strong>을 쉽게 하기 위한 원칙들이다. 그 원칙들에 대해서 하나씩 살펴볼 것인데 오늘은 첫번째 원칙인 <strong>SRP(단일 책임 원칙)</strong>에 대해서 정리를 할 것이다.</p><br><h2 id="단일-책임-원칙이란"><a href="#단일-책임-원칙이란" class="headerlink" title="단일 책임 원칙이란?"></a>단일 책임 원칙이란?</h2><p>단일 책임 원칙이란 말 그대로 책임의 기본 단위인 객체가 하나의 책임만 가져야한다는 것이다. 예를 들어, 자동차를 생각해보자. 자동차는 엔진, 바퀴, 프레임 등등으로 이루어져있다. 엔진은 자동차에게 동력을 주는 일을 바퀴는 자동차가 굴러가게 하는 일을 해준다. 이렇게 하나의 부품은 하나의 역할을 하게 하는데 만약, 바퀴가 자동차에게 동력도 주고 굴러가게 해준다고 하면 어떻게 될까? 바퀴를 교체, 변경해야할 때 동력을 주는 부분과 굴러가는 부분을 모두 변경해야할 것이다.</p><p>이런 상황을 프로그램이라고 생각해보자. 하나의 객체에 여러개의 책임을 가지고 있다면 교체, 변경하는데 있어서 너무 많은 코드를 수정해야할 수도 있다는 의미이다. 객체 지향 프로그램의 장점은 변경과 확장에 대해서 용이하다라는 점인데 이는 반대되는 상황이다. 객체에는 하나의 책임만 있어서 그 책임 변경되어야할 할 때, 수정되어야 한다는 것이 <strong>단일 책임 원칙</strong>이다. 다시 말하면 <strong>객체를 변경해야하는 이유가 단 하나다</strong>라는 것이 <strong>단일 책임 원칙</strong>의 핵심이다.  </p><br><h2 id="책임의-의미와-변경-그리고-분리"><a href="#책임의-의미와-변경-그리고-분리" class="headerlink" title="책임의 의미와 변경 그리고 분리"></a>책임의 의미와 변경 그리고 분리</h2><p><strong>책임</strong>이란 한 객체가 <strong>해야 하는 것, 할 수 있는 것, 해야 하는 것을 잘 할 수 있는 것</strong>을 의미한다. 그래서 내가 생각하기엔 <strong>역할</strong>이라는 단어를 강하게 나타내어 <strong>책임</strong>이라는 용어를 사용하는 것 같다.</p><p>이 때, 위에서 말했듯이 <strong>객체가 변경되는 이유는 단 하나</strong>여야 한다. 그것이 책임을 하나만 가지고 있다는 의미이다.</p><p>그렇기 때문에 하나의 프로그램에서 책임들이 적절하게 분리되어 설계가 되어야 한다.</p><br><h2 id="잘못된-분리"><a href="#잘못된-분리" class="headerlink" title="잘못된 분리"></a>잘못된 분리</h2><p>하지만 반대도 생각을 해야한다. 책임을 분리하다보면 하나의 책임을 여러개의 객체에게 나눌 수도 있는 상황이 온다. 그러면 이 책임을 변경할 때 여러 개의 객체을 모두 수정해야한다. 이를 해결하기 위한 방법으로 AOP(관점 지향 프로그래밍) 사용한다.</p><blockquote><p>AOP는 핵심 기능과 공통 기능을 분리하는데 중점을 두는 프로그램이다. 쉬운 개념은 아니므로 나중에 살펴보기로 한다.</p></blockquote><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>오늘은 <strong>SOLID</strong>의 첫 번째 <strong>단일 책임 원칙</strong>에 대해서 알아봤다. 나름대로 많은 글을 썼지만 핵심은 <strong>객체를 변경하는 이유는 단 하나다.</strong>라는 것이 중점이다. 그러므로 객체 하나에 너무 많은 역할을 부여하지 않고 하나의 책임을 여러 객체의 분산시키지 않는 것이 단일 책임 원칙을 잘 지키는 설계라고 생각을 한다.  </p><br><p>참고 자료</p><ul><li><a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B3400922670" rel="external nofollow noopener noreferrer" target="_blank">Java 객체지향 디자인 패턴</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;SOLID&lt;/strong&gt; 우리가 객체 지향 패턴에 대해서 공부하게 되면 처음으로 듣게 되는 단어이다. &lt;str
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 추상 클래스와 인터페이스</title>
    <link href="http://yoursite.com/2019/08/08/04-java-abstraction/"/>
    <id>http://yoursite.com/2019/08/08/04-java-abstraction/</id>
    <published>2019-08-08T13:38:22.595Z</published>
    <updated>2019-08-13T14:15:00.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>신입 면접 질문 목록을 보면 추상 클래스와 인터페이스에 대해서 묻는 경우가 많다. 나는 추상 클래스는 거의 사용해본적이 없고 인터페이스를 만들고 나서 해당 인터페이스의 명세를 구현하는 경우만 많았다. 왜 그것들을 사용하지는에 대해서 이번 기회에 정리하면 좋겠다고 생각이 들어서 정리를 해본다.</p><br><h2 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h2><p>추상클래스와 인터페이스를 이야기하기 전에 추상화에 대해서 이야기하는 것이 좋을 듯하다. <a href="https://dgahn.github.io/2019/08/07/03-java-oop/" rel="external nofollow noopener noreferrer" target="_blank">Java-객체 지향 프로그래밍</a>에서 이야기 했지만 객체 지향 프로그래밍은 자료구조와 함수에 대해서 먼저 설계를 하고 흐름에 따라서 코드를 작성한다. 이 때, 자료구조와 함수에 대해서 설계를 할 때 <strong>특정 사물에 대해서 공통적인 속성 또는 기능을 정의하는 행위</strong>를 <strong>추상화</strong>라고 한다. </p><p>추상화를 통해서 우리는 객체를 정의할 수 있는데 추상화 과정에서 <strong>비슷한 기능이지만 결과나 구현 내용이 다른 경우</strong>가 있다. 이런 경우, 공통적인 속성 또는 기능등을 추상클래스 또는 인터페이스로 선언을 하고 사용할 수 있다.</p><br><h2 id="추상-클래스"><a href="#추상-클래스" class="headerlink" title="추상 클래스"></a>추상 클래스</h2><p>추상 클래스는 실제 <strong>클래스</strong>이다. 다만, 이 추상 클래스를 상속 받는 하위 클래스가 추상 클래스에서 선언한 추상 메소드들을 보고 반드시 <strong>Overridng</strong> 해야하는 메소드가 무엇인지 알 수 있다. 그렇기 때문에 우리는 추상클래스를 사용하면 일반 클래스처럼 사용하고 하위 클래스가 구현해야되는 기능들을 명시할 수 있다. 그리고 일반 클래스처럼 변수를 선언할 수 있기 때문에 하위 클래스가 해당 변수를 선언하지 않아도 추상 클래스를 통해서 하위 클래스에서 사용할 수 있다.</p><br><h2 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h2><p>인터페이스는 인터페이스를 구현할 구현체가 구현할 기능등을 명세해놓는다. 하지만 변수가 아닌 상수들만 선언할 수 있다. 자바 8 이전 버전에서는 인터페이스에서는 추상 메소드만 선언할 수 있었지만 자바 8 이후부터는 디폴트 메소드, 정적 메소드를 모두 선언해서 사용할 수 있다. 그렇기 때문에 추상 클래스처럼 유사하게 사용할 수 있게 되었다.</p><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>추상 클래스와 인터페이스는 어떤 사물을 추상화하여 여러가지 방법으로 사용하는 것(다형성)을 고려할 때 쓰인다. 그렇기 때문에 너무나 비슷한 것 같은데 무슨 차이가 있을까? 마지막으로 아래에서 공통점과 차이점에 대해서 나열하는 것으로 마무리 하도록 하겠다.</p><h3 id="공통점"><a href="#공통점" class="headerlink" title="공통점"></a>공통점</h3><ul><li><p>추상 메소드, 디폴트 메소드, 정적 메소드를 선언할 수 있다.</p></li><li><p>해당 클래스를 직접 사용하기보단 별도의 클래스를 상속 또는 구현해서 사용한다.</p></li></ul><h3 id="차이점"><a href="#차이점" class="headerlink" title="차이점"></a>차이점</h3><ul><li><p>인터페이스는 객체화할 수 없다. (추상 클래스는 객체화가 가능하다.)</p></li><li><p>인터페이스는 변수를 가질 수 없고 상수만 가질 수 있다. (추상 클래스는 변수를 가질 수 있다.)</p></li><li><p>추상 클래스는 다중 상속이 불가능하다. (인터페이스는 해당 구현체가 여러개의 인터페이스를 구현할 수 있다.)</p></li></ul><p>그렇기 때문에 내가 내린 결론은 아래와 같다.</p><h3 id="사용-용도"><a href="#사용-용도" class="headerlink" title="사용 용도"></a>사용 용도</h3><p>추상 클래스 : 공통적으로 사용할 변수가 있고 추상화 한번에 모든 것이 추상화가 해결된다면 추상 클래스를 사용하는 것이 적합하다.</p><p>인터페이스 : 공통적으로 사용할 상수만 있고 추상화 단계가 복잡하여 구현체가 여러가지를 구현해야하는 경우 사용하는 것이 적합해보인다.</p><h3 id="정말-마지막-결론"><a href="#정말-마지막-결론" class="headerlink" title="정말 마지막 결론.."></a>정말 마지막 결론..</h3><p>java 8 이전에는 인터페이스에 상수, 정적 메소드, 디폴트 메소드를 선언할 수가 없었다. 그렇기 때문에 인터페이스는 구현체에게 구현을 강제할 추상 메소드만 선언을 하였는데 java 8 이후부터는 추상 클래스와 더욱 더 유사하게 사용할 수 있게 되었다.</p><p>그럼에도 추상 클래스와 인터페이스는 개념이 좀 다르다. 추상 클래스는 <strong>상속</strong>과 <strong>다형성</strong>에 기본을 두고 있고 인터페이스는 <strong>다형성</strong>에 기본을 두고 있다. 그렇기 때문에 추상 클래스는 해당 클래스의 기능을 확장하는 개념도 기본으로 들어가 있다.</p><p>참고 자료</p><ul><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">이것이 자바다.</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;신입 면접 질문 목록을 보면 추상 클래스와 인터페이스에 대해서 묻는 경우가 많다. 나는 추상 클래스는 거의 사용해본적이 없고 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 객체 지향 프로그래밍</title>
    <link href="http://yoursite.com/2019/08/07/03-java-oop/"/>
    <id>http://yoursite.com/2019/08/07/03-java-oop/</id>
    <published>2019-08-07T02:20:41.762Z</published>
    <updated>2019-08-07T14:17:59.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>나는 프로그래밍을 대학교에서 C언어로 처음 접했다. 그리고 다음으로 객체 지향 언어라고 불리는 자바를 접하게 되었는데 객체 지향이라는 말이 무엇인지 자바 수업이 끝날 때까지 이해하지 못하였다. 그리고 훗날 세미나를 하면서 객체 지향이라는 것에 대해서 관심을 갖게 된 이유는 내가 만든 프로그램을 수정하면서 너무 많은 것을 변경해야되면서 관심을 갖게 되었다. 객체 지향적으로 설계하는 것이 얼마나 중요한지를 코드를 작성하면서 깨달았다… 아직은 객체지향적인 설계를 하진 못하지만 ^^.. 객체지향의 특징에 대해서 다시한번 정리하려고 한다. </p><br><h2 id="절차-지향-VS-객체-지향"><a href="#절차-지향-VS-객체-지향" class="headerlink" title="절차 지향 VS 객체 지향"></a>절차 지향 VS 객체 지향</h2><p>먼저, 주의해야할 점이 있다. 절차 지향과 객체 지향은 상반된 개념이 아니다. 즉, 절차 지향의 반대가 객체 지향이 아니고 객체 지향의 반대가 절차 지향은 아니다. 그저 바라보는 관점이 다른 것이다. <strong>절차 지향의 경우 순서와 흐름을 먼저 설계하고 자료구조와 함수들을 설계</strong>하는 방식이고 <strong>객체 지향의 경우 자료구조와 함수들을 먼저 설계하고 순서와 흐름을 설계</strong>하는 방식이다. 그렇기 때문에 완전히 다른 방식이 아니라 중점을 어디에 두었냐를 생각해야한다.</p><br><h2 id="객체-지향-프로그래밍의-특징"><a href="#객체-지향-프로그래밍의-특징" class="headerlink" title="객체 지향 프로그래밍의 특징"></a>객체 지향 프로그래밍의 특징</h2><p>객체 지향 프로그램의 가장 큰 장점은 <strong>유지 보수가 용이</strong> 하다는 것이다. 그 이유는 해당 프로그램이 객체 지향적으로 설계된 프로그램이라면 자료구조와 메소드들을 분리할 수 있는 형태로 먼저 설계를 했기 때문에 다른 것으로 대체할 수 있기 때문이다. </p><p>하지만 그에 비해 좋은 설계를 하기 위해서는 많은 시간이 필요하고 객체를 별도로 생성하기 때문에 메모리도 많이 사용하며 여러가지 객체들이 복합적으로 처리하는 것들이 많기 때문에 절차지향에 비해 실제 컴퓨터가 처리하는 시간도 많이 걸린다.</p><br><h3 id="객체-지향의-장점"><a href="#객체-지향의-장점" class="headerlink" title="객체 지향의 장점"></a>객체 지향의 장점</h3><ul><li>유지 보수가 용이하다.</li></ul><h3 id="객체-지향의-단점"><a href="#객체-지향의-단점" class="headerlink" title="객체 지향의 단점"></a>객체 지향의 단점</h3><ul><li><p>좋은 설계를 하기 위한 시간과 노력이 많이 필요하다.</p></li><li><p>메모리를 많이 차지한다.</p></li><li><p>컴퓨터의 실제 처리시간이 비교적 오래 걸린다.     </p></li></ul><br><h2 id="객체-지향의-3가지-요소"><a href="#객체-지향의-3가지-요소" class="headerlink" title="객체 지향의 3가지 요소"></a>객체 지향의 3가지 요소</h2><p>객체 지향 프로그램을 하는데 있어서 중요시 여기는 3가지 요소가 있다. <strong>캡슐화, 상속, 다형성</strong>인데 각각의 특징이 어떤 것을 의미하는지 정리해보자.</p><br><h3 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h3><p>캡슐화는 <strong>객체의 내부 구현 내용을 숨기는 것</strong>이다. 숨기는 이유는 간단하다. 객체를 <strong>손상</strong>되지 않도록 하는 것이다. 자바에서는 객체의 필드와 메소드를 묶어서 사용을 많이 하는데 자바에서 말하는 POJO(Plain Old Java Object)가 바로 그 예시이다. POJO의 예시는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POJO처럼 필드와 메소드를 묶어서 <strong>a</strong> 클래스가 가진 필드 <strong>b</strong> 숨기면 항상 <strong>setB</strong>로 <strong>b</strong>의 값을 변경해야한다. 이렇게 필드를 숨기는 것도 캡슐화의 일종이다. 아래 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  .. 생략</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.initB()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> initB &#123;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .. 생략</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 <strong>b</strong>가 음수라면 <strong>b</strong>를 음수로 초기화해야하는 로직이 있어야한다고 가정하자. 그리고 그 로직을 별도의 메소드로 작성했다고 하고 외부에서는 그 메소드를 호출할 필요가 없다고 하면 위와 같이 접근 제한자로 객체의 기능을 숨길 수가 있다. 그러면 외부에서는 함부로 필드 <strong>b</strong>를 초기화할 수가 없을 것이다.</p><p>이렇게 객체을 손상시키지 않기 위해서 외부에 필드나 메소드를 은닉하는 행위를 <strong>캡슐화</strong>라고 부른다.</p><br><h3 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h3><p>상속은 이미 구현되어 있는 기능(필드 또는 메소드)을 다른 객체가 그대로 사용하거나 변형해서 사용할 수 있도록 해주는 기능이다. 그렇기 때문에 상위 객체(상속을 해주는 객체)의 기능을 이어 받은 하위 객체(상속을 받는 객체)를 작성하는 것이 아예 새로 작성하는 것보다 더 적인 노력이 든다.</p><h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><p>하위 객체가 생성할 때는 상위 객체가 미리 생성이 되어야 한다. 자바에서는 <strong>primitive</strong> 타입을 제외한 타입을 <strong>Heap</strong> 영역에 생성되는데 하위 객체의 생성자를 호출하면 상위 객체의 생성자도 호출되기 때문에 상위 객체가 <strong>Heap</strong>영역에 같이 생성이 된다. (단, 이는 기본 생성자에서 자동으로 상위 객체의 기본 생성자를 불러와주는 것이다. 만약 별도로 만든 생성자라면 해당 생성자 첫 줄에 <strong>super()</strong> 를 통해서 상위 객체의 생성자를 호출해야한다.)</p><br><h3 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h3><p>다형성은 선언한 메소드나 클래스를 다양한 방법으로 동작시키는 것을 의미한다. 아래를 보자. </p><h4 id="1-상속을-이용한-다형성-활용"><a href="#1-상속을-이용한-다형성-활용" class="headerlink" title="1.상속을 이용한 다형성 활용"></a>1.상속을 이용한 다형성 활용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="comment">//  private A a = new A();</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 상속이나 인터페이스를 이용하여 하나의 클래스에 서로 다른 객체를 할당해서 사용할 수 있다. 그러면 <strong>A</strong> 객체를 할당 했을 때는 <strong>a.get1()</strong> 을 호출해서 사용할 수 있고, <strong>B</strong> 객체를 할당 했을 때는 <strong>a.get1()</strong> 또는 <strong>a.get2()</strong> 을 호출하여 사용할 수 있다. 그러므로 A 클래스를 여러가지 방법으로 동작시킬 수 있다.</p><h4 id="2-Override을-이용한-다형성-활용"><a href="#2-Override을-이용한-다형성-활용" class="headerlink" title="2.@Override을 이용한 다형성 활용"></a>2.@Override을 이용한 다형성 활용</h4><p>@Override를 활용하면 <strong>메소드를 재정의</strong>할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="comment">//  private A a = new A();</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러므로 <strong>A</strong> 객체를 할당하느냐 <strong>B</strong> 객체를 할당하느냐에 따라 <strong>a.get()</strong> 를 다르게 사용할 수 있다.</p><h4 id="3-Overloading을-이용한-다형성-활용"><a href="#3-Overloading을-이용한-다형성-활용" class="headerlink" title="3.Overloading을 이용한 다형성 활용"></a>3.Overloading을 이용한 다형성 활용</h4><p>오버로딩을 활용하면 <strong>메소드의 이름을 중복</strong>해서 사용할수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">final</span> String x, <span class="keyword">final</span> String y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조건은 아래와 같다.</p><ul><li><p>메소드의 이름은 같아야 한다.</p></li><li><p>반환형은 달라도 된다.</p></li><li><p>파라미터의 갯수나 자료형이 달라야한다.</p></li></ul><p>참고 자료</p><ul><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">이것이 자바다.</a> </li><li><a href="https://m.blog.naver.com/atalanta16/220249264429" rel="external nofollow noopener noreferrer" target="_blank">스파게티 코드님 블로그</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;나는 프로그래밍을 대학교에서 C언어로 처음 접했다. 그리고 다음으로 객체 지향 언어라고 불리는 자바를 접하게 되었는데 객체 지
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 변수(Primitive)와 메모리 사용</title>
    <link href="http://yoursite.com/2019/07/31/02-java-variable/"/>
    <id>http://yoursite.com/2019/07/31/02-java-variable/</id>
    <published>2019-07-31T14:06:27.843Z</published>
    <updated>2019-07-31T14:06:27.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>회사에서 lombok을 쓰다보니 원시 타입을 잘 사용하지 않아 생각이 나질 않는다. 한번 정리할 겸 해서 블로그에 올려본다.</p><br><h2 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h2><p>Java의 Primitive(원시)타입은 총 8가지가 있다.</p><table><thead><tr><th align="center">기본 타입</th><th align="center">메모리 사용 크기</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1 byte / 8 bit</td></tr><tr><td align="center">char</td><td align="center">2 byte / 16 bit</td></tr><tr><td align="center">short</td><td align="center">2 byte / 16 bit</td></tr><tr><td align="center">int</td><td align="center">4 byte / 32 bit</td></tr><tr><td align="center">long</td><td align="center">8 byte / 64 bit</td></tr><tr><td align="center">float</td><td align="center">4 byte / 32 bit</td></tr><tr><td align="center">double</td><td align="center">8 byte / 64 bit</td></tr><tr><td align="center">boolean</td><td align="center">1 byte / 8 bit</td></tr></tbody></table><br><h2 id="메모리-사용"><a href="#메모리-사용" class="headerlink" title="메모리 사용"></a>메모리 사용</h2><p>모든 프로그램은 아래와 같은 방식으로 메모리를 분리해서 사용한다.</p><p><img src="https://i.imgur.com/tHgmkma.png" alt="2"></p><p><strong>Java</strong>는 데이터 저장 영역을 아래와 같이 더 분류한다.</p><p><img src="https://i.imgur.com/bpzBCzb.png" alt="1"></p><p>Primitive 타입의 변수들은 스택 영역에 값이 직접 할당된다. 그래서 변수를 어떤 타입으로 선언했냐에 따라 이 스택 영역에 해당 변수가 얼마나 많은 크기를 사용하냐가 결정된다.</p><p>참고 자료</p><ul><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">스프링 입문을 위한 자바 객체 지향의 원리와 이해</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;회사에서 lombok을 쓰다보니 원시 타입을 잘 사용하지 않아 생각이 나질 않는다. 한번 정리할 겸 해서 블로그에 올려본다.&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java - 자바 개발 환경</title>
    <link href="http://yoursite.com/2019/07/31/01-java-jdk/"/>
    <id>http://yoursite.com/2019/07/31/01-java-jdk/</id>
    <published>2019-07-31T14:06:22.272Z</published>
    <updated>2019-07-31T14:06:22.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>자바의 가장 큰 장점 중의 하나는 “Write once, run anywhere.(한 번 작성하면 어디서든 실행된다.)” 이다. 이 것을 가능하게 해주는 것은 자바가 가지는 특별한 개발 환경 덕분이다. 자바의 세계는 아래와 같은 3가지 도구로 구성되어 있다.</p><ul><li><p>JVM(Java Virtual Machine) : 자바 가상 기계</p></li><li><p>JRE(Java Runtime Environment) : 자바 실행 환경</p></li><li><p>JDK(Java Development Kit) : 자바 개발 도구</p></li></ul><h2 id="JVM-JRE-JDK-관계"><a href="#JVM-JRE-JDK-관계" class="headerlink" title="JVM, JRE, JDK 관계"></a>JVM, JRE, JDK 관계</h2><ul><li><p>JRE = JVM + 표준 클래스 라이브러리</p></li><li><p>JDK = JRE + 개발에 필요한 도구</p></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM은 컴퓨터로 따지면 물리적인 기계에 해당한다. 자바가 실행할 수 있도록 가상의 공간을 내 컴퓨터에 할당한다. Java 소스 코드를 javac 컴파일러를 통해서 컴파일을 하면 바이트 코드로 변환이 되는데 이 때, 이 바이트 코드를 JVM이 JIT 컴파일 방식으로 코드를 실행한다. (JIT: 실행하는 부분만 필요한 시점에 컴파일 하는 방식)</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>Java Runtime Environment. 말 그대로 자바를 실행할 수 있는 환경을 제공해준다. 예를 들어, 바이트 코드로 전환된 코드를 JVM에게 전달(적재)하는 역할을 JRE에 있는 Java class loader가 해준다.</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JRE, Java 바이트 코드 컴파일러, Java 디버거등으로 구성되어 있다. 실제로 Java를 통해서 개발을 할 때 필요한 도구등을 제공해준다. 간단하게 생각하면 System.out.println()이 JDK에서 제공하는 표준 라이브러리 중 하나인 java.lang에 속한 메소드 중 하나이다.</p><p>참고 자료</p><ul><li><a href="https://namu.wiki/w/Java%20Virtual%20Machine" rel="external nofollow noopener noreferrer" target="_blank">https://namu.wiki/w/Java%20Virtual%20Machine</a></li><li><a href="https://wikibook.co.kr/java-oop-for-spring/" rel="external nofollow noopener noreferrer" target="_blank">이것이 자바다.</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;자바의 가장 큰 장점 중의 하나는 “Write once, run anywhere.(한 번 작성하면 어디서든 실행된다.)” 이다
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo로 블로그 만들기</title>
    <link href="http://yoursite.com/2019/07/30/00-hexo-blog/"/>
    <id>http://yoursite.com/2019/07/30/00-hexo-blog/</id>
    <published>2019-07-30T08:57:27.436Z</published>
    <updated>2019-08-04T10:37:17.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>블로그를 만들고 싶다는 생각에 인터넷을 찾아서 보았다.<br><del>gitlab에서 한번 만든적이 있는데 거의 사용하지 않고 있다.</del> 만들면서 참고한 사이트가 있다.<br>블로그에서는 친절하게 설명을 해주고 있는데 나는 정말 간단하게 명령어를 순서대로 나열할 예정이다. 그러니 자세한 설명을 듣고 싶은 사람은 <a href="https://juicyjusung.github.io/2019/01/23/hexo/Hexo-github-pages%EB%A1%9C-%EA%B7%B8%EB%9F%B4%EC%8B%B8%ED%95%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/" rel="external nofollow noopener noreferrer" target="_blank">링크</a>를 참고하길 바란다.<br>정말 설명을 잘해주셔서 블로그를 띄우는데 많은 도움이 되었다. 다시한번 말하지만 상세한 설정법을 알고 싶으면 링크를 찾아가서 하는 것을 추천한다.</p><h2 id="Git-amp-npm-install"><a href="#Git-amp-npm-install" class="headerlink" title="Git &amp; npm install"></a>Git &amp; npm install</h2><ul><li><a href="https://nodejs.org/ko/download/" rel="external nofollow noopener noreferrer" target="_blank">Node.js 설치</a></li><li><a href="https://git-scm.com/downloads" rel="external nofollow noopener noreferrer" target="_blank">Git 설치</a></li></ul><h2 id="hexo-설치"><a href="#hexo-설치" class="headerlink" title="hexo 설치"></a>hexo 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g hexo</span><br><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><h2 id="hexo-blog-init"><a href="#hexo-blog-init" class="headerlink" title="hexo blog init"></a>hexo blog init</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo-blog(프로젝트 명)</span><br></pre></td></tr></table></figure><h2 id="hexo-실행"><a href="#hexo-실행" class="headerlink" title="hexo 실행"></a>hexo 실행</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo serve</span><br></pre></td></tr></table></figure><h2 id="새로운-테마-적용"><a href="#새로운-테마-적용" class="headerlink" title="새로운 테마 적용"></a>새로운 테마 적용</h2><p>새로운 테마를 적용하기전에 모듈을 몇개 다운 받는다. 무슨 모듈인지는 모르겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i hexo-generator-json-content --save &amp;&amp; npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>새로운 테마를 찾아서 클론 해온다. 여기선 <a href="http://firework.studio/archer-demo/" rel="external nofollow noopener noreferrer" target="_blank">archer</a>를 사용한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/fi3ework/hexo-theme-archer.git</span><br></pre></td></tr></table></figure><p>마지막으로 프로젝트 루트의 <strong>__config.yml</strong>에서 </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">archer</span></span><br></pre></td></tr></table></figure><p>라고 적용하면 새로운 테마 적용은 완성~ 완성된 테마를 구경해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>배포하는 법에 대해서는 <a href="https://juicyjusung.github.io/2019/01/24/hexo/Hexo-github-pages%EB%A1%9C-%EA%B7%B8%EB%9F%B4%EC%8B%B8%ED%95%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/" rel="external nofollow noopener noreferrer" target="_blank">링크</a>을 참고하면 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;서론&quot;&gt;&lt;a href=&quot;#서론&quot; class=&quot;headerlink&quot; title=&quot;서론&quot;&gt;&lt;/a&gt;서론&lt;/h2&gt;&lt;p&gt;블로그를 만들고 싶다는 생각에 인터넷을 찾아서 보았다.&lt;br&gt;&lt;del&gt;gitlab에서 한번 만든적이 있는데 거의 사용하지 않고
      
    
    </summary>
    
    
  </entry>
  
</feed>
